{
  "ziti/identities/enrolling.html": {
    "href": "ziti/identities/enrolling.html",
    "title": "Enrolling an Identity | NetFoundry Ziti",
    "keywords": "Enrolling an Identity All connections made to the Ziti network leverage mutual TLS which means every client needs a valid X509 certificate which it will present to the Ziti network during the connection process. The process of obtaining a key/certificate pair and presenting it securely to the Ziti controller is called \"Enrollment\". Overview All identities need to be enrolled with the Ziti controller so the controller can authenticate the incoming connection. This process is slightly different for each type of identity. NetFoundry has created a tool to aid the enrollment process named ziti-enroller . It is recommended that you use ziti-enroller to complete the enrollment as the process itself complex. Enrollers are available here: Windows MacOS Linux One Time Token Enrollment - Internal PKI Perhaps the easiest path to an enrolled identity is by using the one time token enrollment flow. This flow leverages the PKI configured in the Ziti Controller. Using the one time token flow - the ziti-enroller will generate a private key and a certificate signing request for the Ziti controller to sign. Follow these steps to enroll a one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system: ziti-enroller --jwt ${jwt_file} Important The output from the ziti-enroller is a json file which must be kept secure. This file contains within it the private key used to generate a certificate request which was sent to the Ziti controller and signed. This file should not be transferred or shared and should not be moved from the machine unless you are confident you understand the risks involved in doing so. 3rd Party CA - One Time Token This process is similar to the One Time Token flow from above. This flow expects that a private key and certificate have already been created on the machine that is about to enroll and that the certificate presented is valid to a CA already uploaded to the Ziti controller. Follow these steps to enroll a 3rd Pary CA - one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system. Notice you can provide the name of the identity : ziti-enroller -v --jwt ${jwt_file} --cert ${identity_path_to_cert} --key ${identity_path_to_key} --idname ${identity_name} 3rd Party CA - Auto This enrollment process is almost entirely automated. With \"auto\" no identity needs to exist prior to enrollment. The act of enrolling the identity actually creates the identity. Like \"3rd Party CA - One Time Token\" - this flow expects that a private key and certificate have already been created on the machine that is about to enroll and that the certificate presented is valid to a CA already uploaded to the Ziti controller. This flow also requires that a jwt specifically created for enrollment be downloaded from the CA and the CA uploaded needs to be valid for isAutoCaEnrollmentEnabled. You can get the .jwt by downloading the file from: ${controller_uri}/cas/${ca_id}/jwt"
  },
  "ziti/downloads/enroller.html": {
    "href": "ziti/downloads/enroller.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/identities/overview.html": {
    "href": "ziti/identities/overview.html",
    "title": "Ziti Identities | NetFoundry Ziti",
    "keywords": "Ziti Identities Ziti is built on the foundation of zero-trust. A solid pillar of that foundation requires that all connections in a Ziti-enabled network are authenticated. Identities are the basis for Ziti authentication. All devices connecting to a Ziti network will have an Identity which is presented at the time of a connection being established by both the device initiating the connection and the device receiving the incoming connection. Ziti implements mutual TLS in order to authenticate both sides of a connection. Conceptually an identity can be thought of as congruent to a user account. Identities are logical entities stored inside the Ziti Controller which map an X509 certifcate to a particular named identity. Identities exist not only to authenticate connections but are also used to authorize identities within Ziti. See AppWANs for more information on authoriziation of identities. 3rd Party Certificates The certificate a Ziti Edge client presents can be generated by the Ziti Controller using the configured PKI or this certificate can come from a existing PKI not controlled by the Ziti Controller. Certificates which are not created by the Ziti Controller are referred to as \"3rd Party\" because from the perspective of the Ziti controller the certificates are not from the configured PKI. Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created. There are generally three groups of identities which can be created: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities Choosing an Identity Type Choosing which type of identity you are creating comes down to whether you are using a 3rd Party CA or not. If the network does not have a 3rd Party Certificate configured the only option is to use the One Time Token identity. If one or more 3rd Party CA is installed you will need to understand the intention of each 3rd Party certificate. Each of the types of identities are secure it just depends on your actual network setup as to which type to choose. If you don't know - just use the one time token identity. The identity can always be recreated at a later date and replaced if necessary. One Time Token (OTT) One time token identities are the type of identities available to all Ziti networks. A one time token identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the basic UI provided in the Ziti Edge - Developer Edition . After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create a one time token identity using the ziti cli tool available on the path of the Ziti Edge - Developer Edition . This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to its intended destination. #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview The Ziti controller is capable of using an existing PKI for authentication and authorization rather than to PKI configured in the Ziti Controller. Certificates that are not controlled by the Ziti controller are referred to as \"3rd party\". If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" } 3rd Party CA - One Time Token 3rd Party CA OTT enrollment is closely related to OTT Enrollment . The main difference is the utilization of a 3rd party CA certificate rather than the configured Ziti Edge CA and PKI. In this method, the system does not have access to the 3rd party CA private key and thus cannot provide CSR fulfillment capabilities. Instead it is assumed that the enrolling device has a separate process to acquire signed certificates. Rather than submitting a CSR the client uses an already acquired signed certificate as its client certificate for the enrollment request. The client certificate is validated against the CA certificate tied to the one time token. Similar to the OTT Enrollment process, identities must be provisioned ahead of enrollment in order to generate one time token required and to creat the jwt that can be delivered to enrolling devices. This means that the provisioning of the Ziti Edge identities and the client certificates must be coordinated. Identities can be enrolled with a one time token flow similar to the one time token flow . 3rd Party CA - Auto Enrolled CA Auto Enrollment is useful in situations where devices are provisioned with certificates en-mass that need to be able to register as identities within Ziti Edge. This enrollment method allows for device provisioning processes to skip the manual configuration of Ziti Edge and instead allow clients to present a signed client certificate to generate an identity during the enrollment process. The identity will grant the client access to authenticate only - any authorization will need to be done after the device identities have been created. A certificate can only be used for one identity. The Ziti Edge system does not allow the same certificate to be used for multiple identities. An enrollment request is comprised of a special enrollment URL used to perform an HTTP POST request using the signed client certificate as the TLS client certificate and an optional JSON payload that allows the client to specify the devices display name and internal username. See enrollment for more details on enrolling. New Identity via UI New Identity via UI On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enrolling an Identity All connections made to the Ziti network leverage mutual TLS which means every client needs a valid X509 certificate which it will present to the Ziti network during the connection process. The process of obtaining a key/certificate pair and presenting it securely to the Ziti controller is called \"Enrollment\". Overview All identities need to be enrolled with the Ziti controller so the controller can authenticate the incoming connection. This process is slightly different for each type of identity. NetFoundry has created a tool to aid the enrollment process named ziti-enroller . It is recommended that you use ziti-enroller to complete the enrollment as the process itself complex. Enrollers are available here: Windows MacOS Linux One Time Token Enrollment - Internal PKI Perhaps the easiest path to an enrolled identity is by using the one time token enrollment flow. This flow leverages the PKI configured in the Ziti Controller. Using the one time token flow - the ziti-enroller will generate a private key and a certificate signing request for the Ziti controller to sign. Follow these steps to enroll a one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system: ziti-enroller --jwt ${jwt_file} Important The output from the ziti-enroller is a json file which must be kept secure. This file contains within it the private key used to generate a certificate request which was sent to the Ziti controller and signed. This file should not be transferred or shared and should not be moved from the machine unless you are confident you understand the risks involved in doing so. 3rd Party CA - One Time Token This process is similar to the One Time Token flow from above. This flow expects that a private key and certificate have already been created on the machine that is about to enroll and that the certificate presented is valid to a CA already uploaded to the Ziti controller. Follow these steps to enroll a 3rd Pary CA - one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system. Notice you can provide the name of the identity : ziti-enroller -v --jwt ${jwt_file} --cert ${identity_path_to_cert} --key ${identity_path_to_key} --idname ${identity_name} 3rd Party CA - Auto This enrollment process is almost entirely automated. With \"auto\" no identity needs to exist prior to enrollment. The act of enrolling the identity actually creates the identity. Like \"3rd Party CA - One Time Token\" - this flow expects that a private key and certificate have already been created on the machine that is about to enroll and that the certificate presented is valid to a CA already uploaded to the Ziti controller. This flow also requires that a jwt specifically created for enrollment be downloaded from the CA and the CA uploaded needs to be valid for isAutoCaEnrollmentEnabled. You can get the .jwt by downloading the file from: ${controller_uri}/cas/${ca_id}/jwt"
  },
  "api/csharp/NetFoundry.Ziti.html": {
    "href": "api/csharp/NetFoundry.Ziti.html",
    "title": "Class Ziti | NetFoundry Ziti",
    "keywords": "Class Ziti A collection of static helper methods and properties for Ziti. Inheritance System.Object Ziti Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class Ziti Properties | Improve this Doc OutputDebugInformation A property which controls whether or not output is sent to the System.Diagnostics.Debug output stream. This is a global flag - when toggled all debug messages will show across any connection. Declaration public static bool OutputDebugInformation { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc Debug(String) A helper method to output messages helpful during debugging Ziti-related issues. Declaration public static void Debug(string msg) Parameters Type Name Description System.String msg"
  },
  "api/csharp/NetFoundry.ZitiStatus.html": {
    "href": "api/csharp/NetFoundry.ZitiStatus.html",
    "title": "Enum ZitiStatus | NetFoundry Ziti",
    "keywords": "Enum ZitiStatus An enum representing the outcome of the given Ziti operation. Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public enum ZitiStatus Fields Name Description CONFIG_NOT_FOUND A user error indicating the provided configuration file was not found. CONNABORT An exceptional situation indicating the connection between the client and the Ziti Network Gateway was interrupted CONTROLLER_UNAVAILABLE A network error indicating the Ziti Network Controller was not able to be contacted. EOF A normal status indicating the connection is closed. GATEWAY_UNAVAILABLE A network error indicating the Ziti Network Gateway was not able to be contacted. NOT_AUTHORIZED A user error indicating the identity from the provided configuration file is not authorized to perform the action. OK Indicates a successful outcome SERVICE_UNAVALABLE A user error indicating the service name provided was not available. Either it does not exist or the provided identity does not have sufficient rights to the service. TIMEOUT An exceptional status indicating the operation did not complete within the specified timeout"
  },
  "ziti/intro.html": {
    "href": "ziti/intro.html",
    "title": "| NetFoundry Ziti",
    "keywords": "HI"
  },
  "ziti/services/overview.html": {
    "href": "ziti/services/overview.html",
    "title": "Ziti Services | NetFoundry Ziti",
    "keywords": "Ziti Services A Ziti network is primarily concerned with providing access to \"services\". A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. Services by themselves do not provide a complete mechanism for authorization. That is what an AppWAN is for. To define a service you need to know the following components: Name - what do you want to name your service Ziti Router - the last Ziti Router traffic will be sent to Intercepting Host and Port - what DNS name or IP you wish to intercept traffic on when intecepting traffic Endpoint Service - (if not hosted - see below) the protocol, host, and port traffic sent to Hosting Identity - (is hosted - see below) the identity that will host the service Dark Services One of the benefits of using a Ziti service is that your actual service can be 'dark'. In fact this is the default for any service based entirely in Ziti. Place your service in a secure network with only Ziti in place and nobody in the world can access your service without a valid certificate/identity! Existing services can also be converted to dark via Ziti. Once Ziti is incorporated into your existing network and Ziti endpoints deployed the only access to these services can be through Ziti! Service Name Services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti service is be defined by a name of your choosing and this name is registered with your Ziti controller. You have total control over your service names rather than by a requiring the use of a DNS name or an IP address (underlay concepts). Ziti Router The Ziti Router portion of a service represents the final Ziti Router that traffic will be sent to. From this router the traffic will either be sent to a Ziti Endpoint or to a point outside the Ziti network over the underlay network. If the traffic is destined for a location that is not on the Ziti network overlay this is the router the Ziti network will end up sending the traffic from. If the router is sending traffic to another Ziti Endpoint then the service is said to be \"hosted\". Hosted services cannot specify a router - the Ziti network figures out the best path to the endpoint. Intercepting Host and Port Specified on the service when the traffic destination is outside of the Ziti network onto the underlay. If the Ziti client in use is capable of operating in a seamless/transparent mode then these values will specify the IPv4 address or DNS name to intercept. Any traffic sent to the specified address will be captured and if the destination port is the same as the specified intercepting port the traffic will be routed into the Ziti network. Endpoint Service Specified on the service when the traffic destination is outside of the Ziti network onto the underlay. These fields allow you to choose the protocol, host and port that the actual traffic will be sent to. Note that the host and port do not need to match those specified in the intercept host and port (for seamless/transparent ziti clients). Hosting Identity Specified on the service when the serivce is terminated at another Ziti Endpoint. This field is only valid when the router specified is set to \"hosted\". Creating a Service Here's how you can create a service. New non-hosted Service via UI New hosted Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose Router by name - for example \"ziti-gw01\" if you are using Ziti Edge - Developer Edition For Endpoint Service choose: protocol = tcp host = actual-hostname port = 2222 Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Leave Hosting Identities as is Click save On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-hosted-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose \"Hosted (No Router)\" for the Router Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Select an identity in \"Hosting Identities\" of the identy you want to host the service Click save To change the administrator password using the CLI simply issue these two commands: # ------------------- helpful variables you may need ---------------------- #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the first edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) # ------------------- actual creation of the service ---------------------- #creates a new hosted service ziti edge controller create service ${svc_name} --hosted ${intercept_ip_dns} ${intercept_port} --host-ids ${comma separated identity list} #creates a non-hosted service ziti edge controller create service ${svc_name} \"${destinationHost}\" \"${destinationPort}\" \\ \"${edgeRouter}\" \"tcp:${interceptHost/ip}:${intercept port}\" -c \"${cluster}\""
  },
  "ziti/manage/troubleshooting.html": {
    "href": "ziti/manage/troubleshooting.html",
    "title": "Troubleshooting | NetFoundry Ziti",
    "keywords": "Troubleshooting This is where we'll be doing troubleshooting"
  },
  "api/rest/create-ca-json.html": {
    "href": "api/rest/create-ca-json.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" }"
  },
  "ziti/manage/router.html": {
    "href": "ziti/manage/router.html",
    "title": "| NetFoundry Ziti",
    "keywords": "the router file is here"
  },
  "ziti/manage/pki.html": {
    "href": "ziti/manage/pki.html",
    "title": "Public Key Infrastructure (PKI) | NetFoundry Ziti",
    "keywords": "Public Key Infrastructure (PKI) All Ziti networks leverage Public Key Infrastructure (PKI) in order to provide a secure network. PKI is a complex topic and it is recommended to be familiar with what a PKI is and how to use and configure a PKI before making any decisions about the PKI the Ziti network uses. PKI Options Configuring the PKI for a Ziti network is often done using a self-signed certificate. The ziti command line utility provides a mechanism to create"
  },
  "ziti/services.html": {
    "href": "ziti/services.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Some services deets"
  },
  "glossary/glossary.html": {
    "href": "glossary/glossary.html",
    "title": "Glossary | NetFoundry Ziti",
    "keywords": "Glossary Here you will find a list of terms you may come across as you are using Ziti. Ziti Network, Ziti Ziti is a modern, programmable network overlay with associated edge components, for application-embedded, zero trust network connectivity, written by developers for developers. Ziti is NetFoundry's next-generation programmable networking product. Ziti is used to create Ziti Networks. Network Overlay, Overlay A Ziti network is implemented as an \"overlay\". A network overlay abstracts away the layers beneath it, providing a new set of abstractions for designing and implementing software and systems. Good programming abstractions allow developers to focus on the rules implemented by those abstractions without being concerned with the layers below the abstraction. Ziti's overlay allows developers to focus on connectivity between components without having to be concerned with low-level details of how that connectivity is managed. Underlay We refer to lower-level network concerns as \"underlay\". IP networking would be an example of an underlay concept. Ziti Fabric, Fabric The Ziti Fabric provides the core of the network overlay. The Ziti Fabric implements a routable mesh network, which can provide reliable connectivity between any two points on the network. The fabric provides software extension mechanisms that allow the overlay to be embedded into new overlay applications. The Ziti Edge is an example of an overlay application implemented on top of Ziti Fabric extension mechanisms (Xgress, Xctrl, Xmgmt). Ziti Router, Router A Ziti Router is a process that is installed on a host, which allows it to participate in a Ziti Fabric. The router is designed to be extensible through Ziti fabric extension mechanisms (Xgress), which means that it is capable of \"hosting\" overlay network applications like the Ziti Edge. Ziti Controller, Controller A Ziti Controller is a process that is installed on a host, which allows it to coordinate a Ziti network. The controller is designed to be extensible through Ziti fabric extension mechanisms (Xctrl, Xmgmt), which means that it is capable of hosting extensions to the fabric control and management planes. Xgress (Xctrl, Xmgmt), Ziti Fabric SDK Xgress is a set of extension components for the Ziti fabric, which enable overlay applications to participate in the overlay network. Xgress focuses on extending the data plane, providing interfaces for creating initiating and terminating endpoints. Xctrl and Xmgmt focus on extending the control and management planes of the fabric. Xgress is the core of the Ziti Fabric SDK. Ziti Edge, Edge The Ziti Edge implements the zero trust connectivity framework as an overlay application on top of the Ziti Fabric. The Ziti Edge provides connectivity implementations for a number of important endpoint types, including applications that embed Ziti connectivity through the Ziti Edge SDK. The Ziti Edge provides fallback connectivity solutions for non-Ziti applications using components like the Ziti tunnelers, and the Ziti proxy. Ziti Endpoint SDK, Endpoint SDK, SDK The Ziti Endpoint SDK provides software components that are designed to be embedded into customer applications so that they can participate natively in a Ziti network. The SDK targets golang, Swift, C, C#, and potentially other programming languages, allowing programs in those languages to work with idioms and concepts native to those environments. The SDK provides support for both accessing and hosting services that are available on a Ziti network. Ziti Enabled Application A Ziti Enabled Application is an application that embeds the Ziti Endpoint SDK, such that it can participate on a Ziti network to either access or host services. Ziti Tunneler, Tunneler A Ziti Tunneler provides connectivity for applications that are not Ziti enabled. Our tunneler implementations provide an underlay connectivity component (TUN, tproxy, etc.), and then use the Ziti Endpoint SDK such that they can bridge connectivity onto the Ziti network. Ziti Service, Service A Ziti network is primarily concerned with providing access to \"services\". A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti service would be defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Service Definition A service definition is used to \"bind\" a service to a specific underlay network expression, through one or more nodes on a Ziti overlay network. A service definition usually includes a terminating router (or routers) and one or more SDK or underlay network endpoints where the service can be reached. Session A session is an \"instance\" of a service on behalf of an initiating endpoint, which is connected to a terminating endpoint. A session has strong identity and security between the initiating endpoint, terminating endpoint, and throughout the links between. A session selects a specific set of routers to traverse between the endpoints, and that path can change dynamically due to network performance. Initiating Router, Terminating Router An initiating router is the router which initiates a request for a session on behalf of a connected endpoint. A terminating router is the router which provides access to the service associated with the session request. Every session links an initiating endpoint (through an initiating router), with a terminating endpoint (through a terminating router). Initiating Endpoint, Terminating Endpoint See \"initiating router\" and \"terminating router\" above. The initiating endpoint is the endpoint responsible for requesting connectivity to a service. The terminating endpoint is the endpoint that provides the service. Path The path is the set of Ziti Routers traversed by a session from an initiating router to a terminating router. Ziti aggressively optimizes the path for throughput and reliability, and so it may change during the session."
  },
  "ziti/manage/tunneler.html": {
    "href": "ziti/manage/tunneler.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/appwans/overview.html": {
    "href": "ziti/appwans/overview.html",
    "title": "AppWANs | NetFoundry Ziti",
    "keywords": "AppWANs AppWANs are entities within the Ziti controller which provide identities authorization to services. Having at least one AppWAN is vital because without at least one the Ziti network will have no identities authorized to send traffic over the Ziti network. Creating an AppWAN New AppWAN via UI New AppWAN via UI On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter then name for your AppWAN such as: \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Choose the identity/identities you want to have access to the AppWAN Click save To create an AppWAN using the CLI issue the following commands. (ensure you are logged in ) #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service"
  },
  "ziti/identities/creating.html": {
    "href": "ziti/identities/creating.html",
    "title": "Creating an Identity | NetFoundry Ziti",
    "keywords": "Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created. There are generally three groups of identities which can be created: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities Choosing an Identity Type Choosing which type of identity you are creating comes down to whether you are using a 3rd Party CA or not. If the network does not have a 3rd Party Certificate configured the only option is to use the One Time Token identity. If one or more 3rd Party CA is installed you will need to understand the intention of each 3rd Party certificate. Each of the types of identities are secure it just depends on your actual network setup as to which type to choose. If you don't know - just use the one time token identity. The identity can always be recreated at a later date and replaced if necessary. One Time Token (OTT) One time token identities are the type of identities available to all Ziti networks. A one time token identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the basic UI provided in the Ziti Edge - Developer Edition . After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create a one time token identity using the ziti cli tool available on the path of the Ziti Edge - Developer Edition . This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to its intended destination. #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview The Ziti controller is capable of using an existing PKI for authentication and authorization rather than to PKI configured in the Ziti Controller. Certificates that are not controlled by the Ziti controller are referred to as \"3rd party\". If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" } 3rd Party CA - One Time Token 3rd Party CA OTT enrollment is closely related to OTT Enrollment . The main difference is the utilization of a 3rd party CA certificate rather than the configured Ziti Edge CA and PKI. In this method, the system does not have access to the 3rd party CA private key and thus cannot provide CSR fulfillment capabilities. Instead it is assumed that the enrolling device has a separate process to acquire signed certificates. Rather than submitting a CSR the client uses an already acquired signed certificate as its client certificate for the enrollment request. The client certificate is validated against the CA certificate tied to the one time token. Similar to the OTT Enrollment process, identities must be provisioned ahead of enrollment in order to generate one time token required and to creat the jwt that can be delivered to enrolling devices. This means that the provisioning of the Ziti Edge identities and the client certificates must be coordinated. Identities can be enrolled with a one time token flow similar to the one time token flow . 3rd Party CA - Auto Enrolled CA Auto Enrollment is useful in situations where devices are provisioned with certificates en-mass that need to be able to register as identities within Ziti Edge. This enrollment method allows for device provisioning processes to skip the manual configuration of Ziti Edge and instead allow clients to present a signed client certificate to generate an identity during the enrollment process. The identity will grant the client access to authenticate only - any authorization will need to be done after the device identities have been created. A certificate can only be used for one identity. The Ziti Edge system does not allow the same certificate to be used for multiple identities. An enrollment request is comprised of a special enrollment URL used to perform an HTTP POST request using the signed client certificate as the TLS client certificate and an optional JSON payload that allows the client to specify the devices display name and internal username. See enrollment for more details on enrolling. New Identity via UI New Identity via UI On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt"
  },
  "ziti/identities/create-identity-cli.html": {
    "href": "ziti/identities/create-identity-cli.html",
    "title": "| NetFoundry Ziti",
    "keywords": "#creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt"
  },
  "ziti/clients/windows.html": {
    "href": "ziti/clients/windows.html",
    "title": "Windows | NetFoundry Ziti",
    "keywords": "Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Here you will find the information necessary to successfully use a Ziti SDK to create an application. If there is a term which is not familiar please refer to the glossary . Each SDK has certain syntax unique to the particular language the SDK is targetting. Each SDK presents an api which is as idomatic as possible to present a consistent look and feel for the language or runtime being used."
  },
  "api/clang/index.html": {
    "href": "api/clang/index.html",
    "title": "C Land SDK | NetFoundry Ziti",
    "keywords": "C Land SDK this is the landing page for c"
  },
  "ziti/services/creating.html": {
    "href": "ziti/services/creating.html",
    "title": "Creating a Service | NetFoundry Ziti",
    "keywords": "Creating a Service Here's how you can create a service. New non-hosted Service via UI New hosted Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose Router by name - for example \"ziti-gw01\" if you are using Ziti Edge - Developer Edition For Endpoint Service choose: protocol = tcp host = actual-hostname port = 2222 Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Leave Hosting Identities as is Click save On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-hosted-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose \"Hosted (No Router)\" for the Router Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Select an identity in \"Hosting Identities\" of the identy you want to host the service Click save To change the administrator password using the CLI simply issue these two commands: # ------------------- helpful variables you may need ---------------------- #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the first edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) # ------------------- actual creation of the service ---------------------- #creates a new hosted service ziti edge controller create service ${svc_name} --hosted ${intercept_ip_dns} ${intercept_port} --host-ids ${comma separated identity list} #creates a non-hosted service ziti edge controller create service ${svc_name} \"${destinationHost}\" \"${destinationPort}\" \\ \"${edgeRouter}\" \"tcp:${interceptHost/ip}:${intercept port}\" -c \"${cluster}\""
  },
  "ziti/identities.html": {
    "href": "ziti/identities.html",
    "title": "| NetFoundry Ziti",
    "keywords": "This is all about IDENT-ITIES"
  },
  "ziti/clients/proxy-example.html": {
    "href": "ziti/clients/proxy-example.html",
    "title": "| NetFoundry Ziti",
    "keywords": "The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "ziti/clients/overview.html": {
    "href": "ziti/clients/overview.html",
    "title": "Clients overview | NetFoundry Ziti",
    "keywords": "Clients overview"
  },
  "ziti/clients/macos.html": {
    "href": "ziti/clients/macos.html",
    "title": "MacOS | NetFoundry Ziti",
    "keywords": "MacOS The MacOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/services/create-service-cli.html": {
    "href": "ziti/services/create-service-cli.html",
    "title": "| NetFoundry Ziti",
    "keywords": "# ------------------- helpful variables you may need ---------------------- #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the first edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) # ------------------- actual creation of the service ---------------------- #creates a new hosted service ziti edge controller create service ${svc_name} --hosted ${intercept_ip_dns} ${intercept_port} --host-ids ${comma separated identity list} #creates a non-hosted service ziti edge controller create service ${svc_name} \"${destinationHost}\" \"${destinationPort}\" \\ \"${edgeRouter}\" \"tcp:${interceptHost/ip}:${intercept port}\" -c \"${cluster}\""
  },
  "ziti/appwans.html": {
    "href": "ziti/appwans.html",
    "title": "| NetFoundry Ziti",
    "keywords": "delete"
  },
  "ziti/manage/edge-router.html": {
    "href": "ziti/manage/edge-router.html",
    "title": "Edge Router | NetFoundry Ziti",
    "keywords": "Edge Router The Edge Router is responsible for the"
  },
  "ziti/install/pki.html": {
    "href": "ziti/install/pki.html",
    "title": "| NetFoundry Ziti",
    "keywords": "UNUSED this is install/pki - unreferenced"
  },
  "ziti/install/overview.html": {
    "href": "ziti/install/overview.html",
    "title": "| NetFoundry Ziti",
    "keywords": "UNUSED this is the install/overview.md"
  },
  "ziti/install/edge-router.html": {
    "href": "ziti/install/edge-router.html",
    "title": "| NetFoundry Ziti",
    "keywords": "UNUSED # Edge Router The Edge Router is responsible for the"
  },
  "ziti/install/controller.html": {
    "href": "ziti/install/controller.html",
    "title": "| NetFoundry Ziti",
    "keywords": "UNUSED Hi from the controller file configuration: what does the version mean in config file configuration: why is there a 'db' in the config and why isn't it postgres configuration: logging explain - level/format control section:"
  },
  "ziti/downloads/tunneler.html": {
    "href": "ziti/downloads/tunneler.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/clients/which-client.html": {
    "href": "ziti/clients/which-client.html",
    "title": "Choosing a client | NetFoundry Ziti",
    "keywords": "Choosing a client Once you have a Ziti Network - you are going to require a Ziti-aware client in order to access the network. There are two types of clients and depending on your needs you'll choose to either use a tunneler or you will use an SDK to securely access the Ziti Network. Choosing which type of client you will use to connect to a Ziti Network is a straightfoward process and comes down to a single question. If you are you installing Ziti in front of an existing application which has already been developed and deployed you need to use a tunneler . If you are developing a new product, starting from scratch and you want to take advantage of a fully zero-trust solution you will probably want to use an SDK. Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux Read more on using tunnelers here SDK If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/tunneler.html": {
    "href": "ziti/clients/tunneler.html",
    "title": "Tunnelers | NetFoundry Ziti",
    "keywords": "Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux Each tunneller operates similarly. The goal is to have the tunneler intercecpt traffic destined for Ziti services and forward that traffic over the Ziti overlay instead of the underlay network. There are two basic modes a tunneler operate in: seamless and proxy. A seamless tunneler will transparently intercept traffic via IPv4 address or DNS whereas a tunneler in proxy mode works as a proxy. Seamless mode is transparent to existing services and applications. Proxy mode is not as transparent at all. It requires applications to send traffic to the localhost proxy specifically. This means when running in proxy mode - it does not do any intercepting at all. Here you can learn about the ways each tunneler operates and see the similarities as well as any differences. Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN Android The Android tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months. iOS The iOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months. MacOS The MacOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/sdks.html": {
    "href": "ziti/clients/sdks.html",
    "title": "Ziti SDKs | NetFoundry Ziti",
    "keywords": "Ziti SDKs If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/sdk-quickinfo.html": {
    "href": "ziti/clients/sdk-quickinfo.html",
    "title": "| NetFoundry Ziti",
    "keywords": "If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "test.html": {
    "href": "test.html",
    "title": "this is a markdown test | NetFoundry Ziti",
    "keywords": "this is a markdown test"
  },
  "index.html": {
    "href": "index.html",
    "title": "Overview | NetFoundry Ziti",
    "keywords": "Overview Spin up your network with NetFoundry's Ziti. Getting Started If you're new to Ziti start here to get an overview of what Ziti is. Learn about the components that make up a Ziti-enabled Network and learn how to get a network running. Ziti SDKs Learn about the Ziti SDKs available to use and how to embed them into your own application to provide secure connectivity."
  },
  "ziti/clients/linux.html": {
    "href": "ziti/clients/linux.html",
    "title": "Linux | NetFoundry Ziti",
    "keywords": "Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the edge controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet"
  },
  "ziti/clients/ios.html": {
    "href": "ziti/clients/ios.html",
    "title": "iOS | NetFoundry Ziti",
    "keywords": "iOS The iOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/how-to-choose.html": {
    "href": "ziti/clients/how-to-choose.html",
    "title": "Choosing a Ziti Client | NetFoundry Ziti",
    "keywords": "Choosing a Ziti Client After creating a Ziti Network you will quickly find the need for a client that can connect directly to the overlay. There are two types of clients for Ziti Networks: SDK-based and Tunneler-based. Which client is right for you is a relatively straightforward question to answer."
  },
  "ziti/clients/android.html": {
    "href": "ziti/clients/android.html",
    "title": "Android | NetFoundry Ziti",
    "keywords": "Android The Android tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/cli-snippets/login.html": {
    "href": "ziti/cli-snippets/login.html",
    "title": "| NetFoundry Ziti",
    "keywords": "#load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert"
  },
  "ziti/appwans/creating.html": {
    "href": "ziti/appwans/creating.html",
    "title": "Creating an AppWAN | NetFoundry Ziti",
    "keywords": "Creating an AppWAN New AppWAN via UI New AppWAN via UI On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter then name for your AppWAN such as: \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Choose the identity/identities you want to have access to the AppWAN Click save To create an AppWAN using the CLI issue the following commands. (ensure you are logged in ) #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service"
  },
  "ziti/appwans/create-appwan-cli.html": {
    "href": "ziti/appwans/create-appwan-cli.html",
    "title": "| NetFoundry Ziti",
    "keywords": "To create an AppWAN using the CLI issue the following commands. (ensure you are logged in ) #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service"
  },
  "ziti/index.html": {
    "href": "ziti/index.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Here is the ziti/index file"
  },
  "ziti/docker-quickstart.html": {
    "href": "ziti/docker-quickstart.html",
    "title": "Ziti Quickstart | NetFoundry Ziti",
    "keywords": "Ziti Quickstart This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant ziti concepts refer to the overview . This guide will utilize docker to stand up a full and complete network. If you are unfamiliar with docker take a moment and follow along with the steps for installing and running an application on your operating system. Once you feel comfortable, proceed to the steps below. From Nothing to Network Obtain the software necessary to run a Ziti network. You will need"
  },
  "ziti/appwans/create-appwan-ui.html": {
    "href": "ziti/appwans/create-appwan-ui.html",
    "title": "| NetFoundry Ziti",
    "keywords": "On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter then name for your AppWAN such as: \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Choose the identity/identities you want to have access to the AppWAN Click save"
  },
  "api/csharp.html": {
    "href": "api/csharp.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "api/clang.html": {
    "href": "api/clang.html",
    "title": "| NetFoundry Ziti",
    "keywords": "This is the c# sdk"
  },
  "ziti/manage/manage.html": {
    "href": "ziti/manage/manage.html",
    "title": "Managing Ziti | NetFoundry Ziti",
    "keywords": "Managing Ziti Ziti management needs to be hands off. The only times one should be expected to be concerned with managing a Ziti instance is during the initial installation and when trying to expand the Ziti footprint. Initial Installation Ziti Edge - Developer Edition The initial installation of Ziti is already done for you when using the Ziti Edge - Developer Edition . The installation will contain a controller , an edge router and corresponding PKI . See the corresponding sections for additional details. Expanding Ziti At this time Ziti is only offered as the Ziti Edge - Developer Edition which is not positioned to be expandable. Allowing Ziti to be expanded past the developer experience is planned. Check back in the coming months for more information."
  },
  "ziti/clients/tunneler-overview.html": {
    "href": "ziti/clients/tunneler-overview.html",
    "title": "| NetFoundry Ziti",
    "keywords": "A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux"
  },
  "api/rest/index.html": {
    "href": "api/rest/index.html",
    "title": "| NetFoundry Ziti",
    "keywords": "this is the landing page for rest"
  },
  "api/rest/create-service-rest.html": {
    "href": "api/rest/create-service-rest.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/hello-ziti.html": {
    "href": "ziti/hello-ziti.html",
    "title": "| NetFoundry Ziti",
    "keywords": "If you are seeing this - you have successfully connected to a Ziti network!"
  },
  "samples/index.html": {
    "href": "samples/index.html",
    "title": "SDK Sample Usage | NetFoundry Ziti",
    "keywords": "SDK Sample Usage Here you'll find the samples we have produced to try to illustrate how to use the SDKs. Demo Weather C C# CLANG example is available here: https://github.com/nf-dev/ziti-sdk-c/tree/master/programs/sample_wttr/ /* Copyright 2019 Netfoundry, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ #include <nf/ziti.h> #include <string.h> #include <stdlib.h> #include <stdio.h> #include <uv.h> #define DIE(v) do { \\ int code = (v);\\ if (code != ZITI_OK) {\\ fprintf(stderr, \"ERROR: \" #v \" => %s\\n\", ziti_errorstr(code));\\ exit(code);\\ }} while(0) static size_t total; static nf_context nf; void on_data(nf_connection c, uint8_t *buf, int len) { if (len == ZITI_EOF) { printf(\"request completed: %s\\n\", ziti_errorstr(len)); NF_close(&c); NF_shutdown(nf); } else if (len < 0) { fprintf(stderr, \"unexpected error: %s\\n\", ziti_errorstr(len)); NF_close(&c); NF_shutdown(nf); } else { total += len; printf(\"%*.*s\", len, len, buf); } } static void on_write(nf_connection conn, ssize_t status, void *ctx) { if (status < 0) { fprintf(stderr, \"request failed to submit status[%zd]: %s\\n\", status, ziti_errorstr(status)); } else { printf(\"request success: %zd bytes sent\\n\", status); } } void on_connect(nf_connection conn, int status) { DIE(status); printf(\"sending HTTP request\\n\"); uint8_t *req = \"GET /Rochester HTTP/1.0\\r\\n\" \"Accept: */*\\r\\n\" \"Connection: close\\r\\n\" \"Host: wttr.in\\r\\n\" \"User-Agent: curl/7.59.0\\r\\n\" \"\\r\\n\"; DIE(NF_write(conn, req, strlen(req), on_write, NULL)); } void on_nf_init(nf_context _nf, int status, void* ctx) { DIE(status); nf = _nf; nf_connection conn; DIE(NF_conn_init(nf, &conn, NULL)); DIE(NF_dial(conn, \"demo-weather\", on_connect, on_data)); } int main(int argc, char** argv) { #if _WIN32 //changes the output to UTF-8 so that the windows output looks correct and not all jumbly SetConsoleOutputCP(65001); #endif int res; uv_loop_t *loop = uv_default_loop(); DIE(NF_init(argv[1], loop, on_nf_init, NULL)); // loop will finish afger the request is complete and NF_shutdown is called uv_run(loop, UV_RUN_DEFAULT); printf(\"========================\\n\"); NF_free(&nf); } C# Example is available here: https://github.com/nf-dev/ziti-sdk-csharp/tree/initial_commit/Ziti.Core.Console using System; using System.IO; using System.Text; using System.Threading.Tasks; using NetFoundry; namespace Ziti.Core.Example { class Program { static async Task Main(string[] args) { byte[] wttrRequestAsBytes = Encoding.UTF8.GetBytes(\"GET / HTTP/1.0\\r\\n\" + \"Accept: *-/*\\r\\n\" + \"Connection: close\\r\\n\" + \"User-Agent: curl/7.59.0\\r\\n\" + \"Host: wttr.in\\r\\n\" + \"\\r\\n\"); string path = @\"c:/path/to/enrolled.id.json\"; //makes the output pretty - and not jumbly Console.OutputEncoding = Encoding.UTF8; /* Only needed when debugging Environment.SetEnvironmentVariable(\"ZITI_LOG\", \"6\"); NetFoundry.Ziti.OutputDebugInformation = true; */ ZitiIdentity id = new ZitiIdentity(path); id.InitializeAndRun(); //connect to the Ziti network //make a new stream using the identity ZitiStream zitiStream = new ZitiStream(id.NewConnection(\"demo-weather\")); //send the reqeust await zitiStream.WriteAsync(wttrRequestAsBytes, 0, wttrRequestAsBytes.Length); using (MemoryStream ms = new MemoryStream()) using (StreamReader sr = new StreamReader(ms)) { //display the bytes by reading from the stream and writing to the console await LocalPumpAsync(zitiStream, System.Console.OpenStandardOutput()); string output = sr.ReadToEnd(); System.Diagnostics.Debug.WriteLine(output); } } private const int DefaultStreamPumpBufferSize = 64 * 1024; public static async Task LocalPumpAsync(Stream input, Stream destination) { int count = DefaultStreamPumpBufferSize; byte[] buffer = new byte[count]; int numRead = await input.ReadAsync(buffer, 0, count).ConfigureAwait(false); while (numRead > 0) { destination.Write(buffer, 0, numRead); //writes are synchronous for now - without syncronous writes there's a lock that's //not freeing up //await destination.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); numRead = await input.ReadAsync(buffer, 0, count).ConfigureAwait(false); } } } }"
  },
  "samples/csharp.html": {
    "href": "samples/csharp.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "samples/clang.html": {
    "href": "samples/clang.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "api/csharp/NetFoundry.ZitiConnection.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.html",
    "title": "Class ZitiConnection | NetFoundry Ziti",
    "keywords": "Class ZitiConnection Represents a connection through the Ziti network. Supports both System.IO.Stream use-cases as well as callback-based. Inheritance System.Object ZitiConnection Implements System.IDisposable Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiConnection : IDisposable Methods | Improve this Doc Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) Establishes the necessary connecctivity and callbacks to send data through the NetFoundry network Declaration public void Dial(ZitiConnection.OnConnected onConnected, ZitiConnection.OnDataReceived onDataReceived) Parameters Type Name Description ZitiConnection.OnConnected onConnected Once the connection is established this callback is called ZitiConnection.OnDataReceived onDataReceived Called each time data is received over the NetFoundry network Exceptions Type Condition System.InvalidOperationException Thrown when the ZitiConnection has had AsStream invoked previously | Improve this Doc Dispose() Closes the ZitiConnection and cleans up as needed Declaration public void Dispose() | Improve this Doc Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) Writes the provided data over the NetFoundry network Declaration public void Write(byte[] data, int count, ZitiConnection.OnDataWritten onDataWritten, object context) Parameters Type Name Description System.Byte [] data A buffer holding the information to be sent over the NetFoundry network System.Int32 count How many bytes of the buffer (starting at position 0) to write ZitiConnection.OnDataWritten onDataWritten A callback to be invoked after the data is written to the NetFoundry network System.Object context Any object, provided back to the caller of this functionin the onDataWritten callback Implements System.IDisposable"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnConnected.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnConnected.html",
    "title": "Delegate ZitiConnection.OnConnected | NetFoundry Ziti",
    "keywords": "Delegate ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnConnected(ZitiConnection zitiConnection, ZitiStatus status); Parameters Type Name Description ZitiConnection zitiConnection The ZitiConnection which as passed to the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) method ZitiStatus status The ZitiStatus representing the outcome of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived)"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html",
    "title": "Delegate ZitiConnection.OnDataWritten | NetFoundry Ziti",
    "keywords": "Delegate ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a System.IO.Stream (callback based Ziti) Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataWritten(ZitiStatus status, int bytesWritten, object context); Parameters Type Name Description ZitiStatus status A ZitiStatus that represents the state of the connection which initiated this callback. If NOT OK appropriate actions should be taken System.Int32 bytesWritten A count of how many bytes were able to be written. System.Object context The context that was supplied during the Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) invocation"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html",
    "title": "Delegate ZitiConnection.OnDataReceived | NetFoundry Ziti",
    "keywords": "Delegate ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataReceived(ZitiStatus status, byte[] data, int count); Parameters Type Name Description ZitiStatus status The ZitiStatus representing the outcome of the write operation. System.Byte [] data A buffer representing the data that was received over the Ziti network. Data will always start at postiion 0. System.Int32 count The number of bytes received in this interation. Data will always start at postiion 0."
  },
  "api/csharp/NetFoundry.html": {
    "href": "api/csharp/NetFoundry.html",
    "title": "Namespace NetFoundry | NetFoundry Ziti",
    "keywords": "Namespace NetFoundry Classes Ziti A collection of static helper methods and properties for Ziti. ZitiConnection Represents a connection through the Ziti network. Supports both System.IO.Stream use-cases as well as callback-based. ZitiException Represents a Ziti-specific exception ZitiIdentity Represents an enrolled identity ZitiStream A representation of a standard System.IO.Stream which utilizes the NetFoundry network Enums ZitiStatus An enum representing the outcome of the given Ziti operation. Delegates ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a System.IO.Stream (callback based Ziti)"
  },
  "api/csharp/NetFoundry.ZitiStream.html": {
    "href": "api/csharp/NetFoundry.ZitiStream.html",
    "title": "Class ZitiStream | NetFoundry Ziti",
    "keywords": "Class ZitiStream A representation of a standard System.IO.Stream which utilizes the NetFoundry network Inheritance System.Object System.MarshalByRefObject System.IO.Stream ZitiStream Implements System.IDisposable Inherited Members System.IO.Stream.Null System.IO.Stream.BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object) System.IO.Stream.BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object) System.IO.Stream.Close() System.IO.Stream.CopyTo(System.IO.Stream) System.IO.Stream.CopyTo(System.IO.Stream, System.Int32) System.IO.Stream.CopyToAsync(System.IO.Stream) System.IO.Stream.CopyToAsync(System.IO.Stream, System.Int32) System.IO.Stream.CopyToAsync(System.IO.Stream, System.Int32, System.Threading.CancellationToken) System.IO.Stream.CreateWaitHandle() System.IO.Stream.Dispose() System.IO.Stream.EndRead(System.IAsyncResult) System.IO.Stream.EndWrite(System.IAsyncResult) System.IO.Stream.FlushAsync() System.IO.Stream.FlushAsync(System.Threading.CancellationToken) System.IO.Stream.ObjectInvariant() System.IO.Stream.ReadAsync(System.Byte[], System.Int32, System.Int32) System.IO.Stream.ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken) System.IO.Stream.ReadByte() System.IO.Stream.Synchronized(System.IO.Stream) System.IO.Stream.WriteAsync(System.Byte[], System.Int32, System.Int32) System.IO.Stream.WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken) System.IO.Stream.WriteByte(System.Byte) System.IO.Stream.CanTimeout System.IO.Stream.ReadTimeout System.IO.Stream.WriteTimeout System.MarshalByRefObject.GetLifetimeService() System.MarshalByRefObject.InitializeLifetimeService() System.MarshalByRefObject.MemberwiseClone(System.Boolean) System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiStream : Stream, IDisposable Constructors | Improve this Doc ZitiStream(ZitiConnection) Creates a ZitiStream from the provided ZitiConnection Declaration public ZitiStream(ZitiConnection conn) Parameters Type Name Description ZitiConnection conn The ZitiConnection to create a ZitiStream from Properties | Improve this Doc CanRead Indicates if the stream can be read from Declaration public override bool CanRead { get; } Property Value Type Description System.Boolean Overrides System.IO.Stream.CanRead | Improve this Doc CanSeek Seeking is not supported Declaration public override bool CanSeek { get; } Property Value Type Description System.Boolean Overrides System.IO.Stream.CanSeek | Improve this Doc CanWrite indicates if the stream is ready for writing Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean Overrides System.IO.Stream.CanWrite | Improve this Doc Length unsupported - always returns 0 Declaration public override long Length { get; } Property Value Type Description System.Int64 Overrides System.IO.Stream.Length | Improve this Doc Position unsupported - always returns 0 Declaration public override long Position { get; set; } Property Value Type Description System.Int64 Overrides System.IO.Stream.Position Exceptions Type Condition System.NotImplementedException Thrown when calling set Methods | Improve this Doc Dispose(Boolean) Disposes of the ZitiStream , cleaning up any retained resources Declaration protected override void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing Overrides System.IO.Stream.Dispose(System.Boolean) | Improve this Doc Flush() Flushes bytes Declaration public override void Flush() Overrides System.IO.Stream.Flush() | Improve this Doc PumpAsync(Stream) Asynchronously pumps this ZitiStream to/from the destination System.IO.Stream Declaration public Task PumpAsync(Stream destination) Parameters Type Name Description System.IO.Stream destination Returns Type Description System.Threading.Tasks.Task | Improve this Doc PumpAsync(Stream, Stream) Asynchronously pumps data between the input System.IO.Stream and destination System.IO.Stream Declaration public static Task PumpAsync(Stream input, Stream destination) Parameters Type Name Description System.IO.Stream input The input stream System.IO.Stream destination The destination stream Returns Type Description System.Threading.Tasks.Task A System.Threading.Tasks.Task which is awaitable | Improve this Doc Read(Byte[], Int32, Int32) Reads data into the provided buffer Declaration public override int Read(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer to read data into System.Int32 offset The position in the bufer to begin appending data System.Int32 count The number of bytes to append Returns Type Description System.Int32 Returns the number of bytes read Overrides System.IO.Stream.Read(System.Byte[], System.Int32, System.Int32) Exceptions Type Condition System.NotSupportedException Thrown if the stream is not ready for reading System.ArgumentNullException Thrown if the buffer provided is null System.ArgumentException Thrown if the offset and count provided is larger than the buffer provided System.ArgumentOutOfRangeException Thrown if the offset or count provided is less than 0 | Improve this Doc Seek(Int64, SeekOrigin) unsupported Declaration public override long Seek(long offset, SeekOrigin origin) Parameters Type Name Description System.Int64 offset System.IO.SeekOrigin origin Returns Type Description System.Int64 Overrides System.IO.Stream.Seek(System.Int64, System.IO.SeekOrigin) | Improve this Doc SetLength(Int64) unsupported Declaration public override void SetLength(long value) Parameters Type Name Description System.Int64 value Overrides System.IO.Stream.SetLength(System.Int64) | Improve this Doc Write(Byte[], Int32, Int32) Writes the provided buffer over the ZitiNetwork Declaration public override void Write(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer containing data to write System.Int32 offset The position in the buffer to read from System.Int32 count The number of bytes to write from the buffer Overrides System.IO.Stream.Write(System.Byte[], System.Int32, System.Int32) Exceptions Type Condition System.NotSupportedException Thrown if the stream is not ready for writing System.ArgumentNullException Thrown if the buffer provided is null System.ArgumentException Thrown if the offset and count provided is larger than the buffer provided System.ArgumentOutOfRangeException Thrown if the offset or count provided is less than 0 Implements System.IDisposable"
  },
  "api/csharp/NetFoundry.ZitiIdentity.html": {
    "href": "api/csharp/NetFoundry.ZitiIdentity.html",
    "title": "Class ZitiIdentity | NetFoundry Ziti",
    "keywords": "Class ZitiIdentity Represents an enrolled identity Inheritance System.Object ZitiIdentity Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiIdentity Constructors | Improve this Doc ZitiIdentity(String) Creates a new ZitiIdentity using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path) Parameters Type Name Description System.String path The path to the enrolled Ziti identity | Improve this Doc ZitiIdentity(String, Int32) Creates a new ZitiIdentity with the provided timeout (ms) using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path, int timeOutInMillis) Parameters Type Name Description System.String path The path to the enrolled ziti identity System.Int32 timeOutInMillis timeout in milliseconds Properties | Improve this Doc PathToConfigFile The path to the enrolled identity Declaration public string PathToConfigFile { get; } Property Value Type Description System.String Methods | Improve this Doc Dump() Dumps debug information to standard out. Only used when debugging Declaration public void Dump() | Improve this Doc InitializeAndRun() Initializes this identity with the NetFoundry network Declaration public void InitializeAndRun() Exceptions Type Condition System.Exception Thrown when the path to the configuration file no longer exists or if the provided identity file is not valid | Improve this Doc NewConnection(String) Creates a new ZitiConnection for this identity Declaration public ZitiConnection NewConnection(string serviceName) Parameters Type Name Description System.String serviceName The service name to create a ZitiConnection for Returns Type Description ZitiConnection A ZitiConnection that is ready to be Dialed or converted to a stream via AsStream() Exceptions Type Condition ZitiException Thrown when the serviceName provided does not exist | Improve this Doc ServiceAvailable(String) Determines if the provided serviceName is available for this identity Declaration public bool ServiceAvailable(string serviceName) Parameters Type Name Description System.String serviceName The service name to verify Returns Type Description System.Boolean If the service exists - true, false if not | Improve this Doc Shutdown() instructs this identity to disconnect from the NetFoundry network Declaration public void Shutdown()"
  },
  "api/csharp/NetFoundry.ZitiException.html": {
    "href": "api/csharp/NetFoundry.ZitiException.html",
    "title": "Class ZitiException | NetFoundry Ziti",
    "keywords": "Class ZitiException Represents a Ziti-specific exception Inheritance System.Object System.Exception ZitiException Implements System.Runtime.Serialization.ISerializable Inherited Members System.Exception.GetBaseException() System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext) System.Exception.GetType() System.Exception.ToString() System.Exception.Data System.Exception.HelpLink System.Exception.HResult System.Exception.InnerException System.Exception.Message System.Exception.Source System.Exception.StackTrace System.Exception.TargetSite System.Exception.SerializeObjectState System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiException : Exception, ISerializable Constructors | Improve this Doc ZitiException(String) The basic constructor for creating a ZitiException Declaration public ZitiException(string message) Parameters Type Name Description System.String message The message Implements System.Runtime.Serialization.ISerializable"
  },
  "ziti/overview.html": {
    "href": "ziti/overview.html",
    "title": "Overview | NetFoundry Ziti",
    "keywords": "Overview Why Ziti? Ziti represents the next generation of secure networking for your applications and has arrived with the Ziti platform, created by NetFoundry, Inc ! The Ziti Controller and the Ziti Edge Router combine to form a secure, Zero Trust entry point into your network or as a secure zero-trust proxy to other hosted services. Getting started with Ziti If you are looking to jump right in feet first you can follow along this with our up-and-running quickstart guide . The quickstart will leverage Amazon Web Services (AWS) and will have you launch an AMI which will get you up and running in no time. This environment is perfect for evaluators to get to know Ziti and the capabilities it offers. The environement was not designed for large scale deployment or for long-term usage. If you are looking for a managed service to help you run a truly global, scalable network browse over to our website at http://netfoundry.io to learn more. Overview of a Ziti Network The Ziti Network (Ziti) is composed of the following building blocks: Controller, Router, Edge Router, Edge Clients. These components are used in conjunction to provide secure connectivity between two points such as a client to a server. This type of network is considered an overlay network because it provides secure connectivity on top – or “overlaying” – existing networking infrastructure. Here's an overview of a network: ZITI CONTROLLER The NetFoundry Ziti Controller is the central function of the NetFoundry Ziti Network. The Controller provides the configuration plane. It is responsible for configuring Ziti services as well as being the central point for managing the identities used by users, devices and the nodes making up the Ziti Network. Lastly but critically, the Controller is responsible for authentication and authorization for every connection in the Ziti network. The Controller must be configured with public key infrastructure (pki). The configured pki is used to create secure, mutually authenticated TLS (mTLS) network connections between any two pieces of the Ziti Network. The Controller does not provide its own pki but for the Controller to sign certificate requests (CSR) the Controller will need to be configured with a key and certificate used for signing. (Optionally, the Ziti CLI can be used to generate a pki if needed) The controller also supports using a third-party pki should the operator of the Ziti Network have an existing pki they wish to reuse. Utilizing a third-party CA pushes the burden of obtaining and distributing properly signed certificates to the operator of the Ziti network but for sophisticated customers this might make overall management of the network easier. The Controller uses an out of process database (Postgres) to store the information needed to manage the network. ZITI FABRIC ROUTER Ziti Fabric Routers are the fundamental building blocks of the Ziti Network. These routers are responsible for securely and reliably delivering traffic from one Ziti Network node to the traffic’s destination. Fabric Routers are linked together to form a mesh network. This mesh is constantly being monitored for latency and the fastest paths are used when routing traffic to the destination. The monitoring also allows for active failover to ensure a reliable network connection even in the case of a node failure. ZITI EDGE ROUTER Another fundamental building block of the Ziti Network is the Edge Router. The Edge Router is the entry point for Edge Clients connecting to the Ziti Network. The Edge Router is a specialized Router incorporating the functionality of a Router to enable it to route traffic over the Ziti network as a Router would to a given destination. The Edge Router in combination with the Controller is responsible for authenticating and authorizing Ziti Edge Clients. ZITI EDGE CLIENTS Connecting to the Ziti Network requires a Ziti Edge Client. Edge Clients are designed to work with both brownfield and greenfield applications. If the solution being developed includes developing new software NetFoundry offers SDKs targeting various languages and runtimes to provide fast, reliable and secure connectivity. These SDKs provide the capabilities needed to securely connect to the Ziti Network and are designed to be easily incorporated into the target application. When adding secure connectivity to an already existing solution NetFoundry offers specialized Edge Clients called tunnelers which provide seamless, secure connectivity and do not require changes to the target application. USING ZITI Once the Ziti Network is established and deployed the next step is to configure the software-powered network. The three main concepts necessary to configure a Ziti Network are: Identities, Services, and AppWANs. SERVICES A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti Service is defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Services also declare a node where traffic that exits the Ziti Network needs to be sent do before exiting. It’s possible for the node traffic enters to be the same it exits and it’s possible for traffic needing to traverse the Ziti Network Routers to reach the correct node. Simply specifying the node is all the end-user need do, the Ziti Network handles the rest. IDENTITIES Identities represent individual endpoints in the Ziti Network which can establish connectivity. All connections made within the Ziti Network are mutually authenticated using X509 Certificates. Every Identity is mapped to a given certificate’s signature. Ziti Edge Clients present this certificate when initiating connections to the Ziti Network. The presented certificate is used by the Ziti Network to authorize the client and enumerate the services the Identity is authorized to use. AppWAN The AppWAN is concept created to encapsulate the mapping between services and identities in a software-powered network. In the simplest terms, AppWANs are a group of services and a group of identities. The act of adding a service to an AppWAN will grant the identities in that AppWAN access to the given service. Similarly adding an identity to an AppWAN will grant that identity access to the services mapped in that AppWAN."
  },
  "ziti/manage/controller.html": {
    "href": "ziti/manage/controller.html",
    "title": "Ziti Controller | NetFoundry Ziti",
    "keywords": "Ziti Controller The Ziti Controller is the process that coordinates a Ziti network. It is responsible for authenticating incoming connections from identities and authorizing identities to services and provides a ReST-based API for other processes to interact with it. Installation Steps Installing a Ziti Network from scratch, like anything, is easy once you know how. Getting to knowing how can take some time. The goal of these pages are to get you from nothing to network the long way. If you want to take the quick route you should stop now and follow the quickstart instead. It is designed to get a Edge-only Ziti network running in no time. A basic Edge-only Ziti Network is composed of two (or three depending on how you count the database) pieces. The Controller and the Edge Router. Controller Prerequisite - Database There are a few prerequisites necessary before being able to deploy your first Controller. The first thing you will need is a database. At this time the Ziti Controller is using a Postgres instance. Setting up and managing a Postgres database is a complex task beyond the scope of this guide. This guide is intended to be illustrative of installing and managing the Ziti Controller and not maintaining a Postgres installation. Refer to the documentation from Postgres for asistance setting up a Postgres database. Prerequistie - PKI Public Key Infrastructure (PKI) is a complex topic. See the pki page for additional details about the sort of needs the Ziti controller requires for the PKI. Configuration Sizing Guidelines configuration: what does the version mean in config file configuration: why is there a 'db' in the config and why isn't it postgres configuration: logging explain - level/format control section:"
  },
  "ziti/quickstart.html": {
    "href": "ziti/quickstart.html",
    "title": "Ziti Quickstart | NetFoundry Ziti",
    "keywords": "Ziti Quickstart This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant ziti concepts refer to the overview . From Nothing to Network To get started with Ziti here are the steps you will need to accomplish: Get Ziti Obtain, then change the default password Create an Identity Enroll the Identity Create a Service Create an AppWAN Test the Service Start Ziti Getting Started in AWS This guide will leverage an Amazon Machine Image (AMI) delivered via the AWS Marketplace . Using the image you will have an instance of Ziti to use as you please within minutes. If you are unfamiliar AWS you'll want to take some time to come up to speed. You will need an account, and you'll want to become familiar with the console. Start here and when you feel ready - come back to this guide. Starting a Ziti Instance NetFoundry has provided an Amazon Machine Image (AMI) delivered via the AWS Marketplace to make it easy for you to deploy a fully functional Ziti-based network. Follow the prompts and launch a new AMI. You will need to make a few key decisions that might affect your Ziti-based network. Important This is IMPORTANT. Make sure you consider and understand any security implications of the choices made when starting the AMI Virtual Private Cloud (VPC): for the instance to be put into. Choosing the VPC will determine what network resources are available to your Ziti network Subnet: The subnet you choose further defines what resources the instance will have access to. If you have a service that is not visible to the public internet and you wnat to use Ziti to secure that service make sure you put the Ziti instance on the proper subnet Security Group: You will want to put the Ziti instance into a security group that allows access from the public internet on ports: 22, 443, 1280, 3022. port 22 - the default port that ssh uses. This is how you will log into the bare AMI after it is launched. port 443 - a small UI is delivered via a web server that runs on port 443, using self-signed certificates port 1280 - the preselected port the Ziti controller will serve its API over port 3022 - the preselected port for data channels to the Ziti Edge Router Important Make sure you have the private key corresponding to the public key you choose. Without the private key - you will not be able to authenticate to the bare AMI. Obtain and Change the Default Password When first launched - the AMI will deposit a file into the file system at ~/.config/ziti/ziti-controller/credentials.json. Note Since this is your first Ziti deployment this system is expected to be transient. If the IP address or DNS entry changes (such as a system reboot) the image needs to be reconfigured becuase the certificates will no longer be valid. This file is used to reconfigure the system in this event and it happens automatically on startup. Now, ssh to the newly created machine. Once there you can obtain the username and password for your Ziti controller by issuing this command: jq -r .password ~/.config/ziti/ziti-controller/credentials.json You can choose to keep this password or change it to something easier to remember. If you change the password, please remember to use a strong password which is not easy to guess. Tip Once the password is changed - update the credentials.json file with the current password if you want the system to automatically update the certificates in the event of the image losing its IP address or DNS entry. Change via UI Change via CLI These AMIs will be provided with a self-signed certificate generated during securely during the bootup process. See changing pki for more information. Log into the UI using the password obtained in the prior step In the lower left corner, click the icon that looks like a person and choose \"Edit Profile\" Enter the current password along with a new/confirmed password and click \"Save\" To change the administrator password using the CLI simply issue these commands: Note You will need to login one time in order to use the ziti cli: #load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert #update the admin user. This command will prompt you to enter the password ziti edge controller update authenticator updb -s Create an Identity All connections to Ziti are mutually authenticated TLS connections. Identites map a given certificate to an identity within the Controller. Read more about Identities here Creating an identity via the UI or CLI is easy: New Identity via UI New Identity via CLI On the left side click \"Edge Identities\" In the top right corner of the screen click the \"plus\" image to add a new identity Enter the name of the identity you would like to create Choose the type: Device, Service, User (choose User for now) Leave the enrollment type as \"One Time Token\" Click save To create a new identity using the CLI simply issue these commands: #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enroll the New Identity Identities are not truly enabled until they are enrolled. Enrollment is a complex process. NetFoundy has created a tool specifically for this task to ensure safe and secure enrollment of identities. Download the enroller for your operating system. Windows MacOS Linux Download the jwt from the UI by clicking the icon that looks like a certificate (save the file as NewUser.jwt) or if you used the CLI from the output location specified when creating the user. In a command line editor, change to the folder containing the jwt. Enroll the identity by running ziti-enroller --jwt NewUser.jwt The ziti-enroller will output a new json file named NewUser.json . This file is precious and must be protected as it contains the identity of the given user. Create a Service With an identity created it's now time to create a service. Read more about Services here . For this example we are going to choose a simple website that is available on the open internet . This site will return the IP address you are coming from. Click this link now and discover what the your external IP is. New Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"ethzero-ui\" Enter a host name for the service. Enter \"ethzero.ziti.ui\" Enter port 80 Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = eth0.me port = 80 Select \"demo-c01\" for the cluster Leave Hosting Identities as is Click save To create a new service using the CLI simply issue these two commands: #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create service ethzero-cli \"ethzero.ziti.cli\" \"80\" \"$edgeRouter\" \"tcp:eth0.me:80\" -c \"$cluster\" Create an AppWan AppWANs are used to to authorize identities to services and allow you to choose the terminating node for traffic destined to your service. Read more about appwans here New AppWAN via UI New AppWAN via CLI On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Make sure you pick ethzero-ui Choose the identity you created before (NewUser) Click save [To create an AppWAN using the CLI issue the following commands: #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service] Test It Ok, you're almost ready to test your Ziti setup! Now you need to acquire a pre-built client from NetFoundry. The simplest way to test your setup is to get the ziti-tunnel for your OS. The ziti-tunnel has a mode which acts as a proxy into the Ziti overlay network. You will need the enrolled identity json file created in the previous step and this will require running a command. Here are the steps to verify your Ziti network and configuration are all working properly: Open a command prompt ensure ziti-tunnel and NewUser.json are in the same directory and cd to this directory run the ziti-tunnel in proxy mode: ziti-tunnel proxy -i NewUser.json ethzero-ui:1111 ziti-tunnel proxy -i NewUser.json ethzero-cli:2222 navigate your web browser to (or use curl) to obtain your IP address by going to http://localhost:1111/ At this point you should see the external IP address of your Amazon instance. Delivered to your machine safely and securely over your Ziti network."
  }
}